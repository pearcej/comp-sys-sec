<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="ch2-cryptography" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Cryptography</title>
<section xml:id="why-do-we-need-cryptography">
		<title>Why do we need cryptography?</title>
	<p>
		This chapter is meant to serve as a brief and gentle introduction to the cryptographic concepts often encountered in the field of security. It is by no means exhaustive but it should provide a basis for a better understanding of why protocols are designed the way they are. Cryptography is a method of scrambling data into non-readable text. It allows us to transform data into a secure form so that unauthorized users cannot view it.
	</p>
	
					<p>
					Cryptography is used to set up secure channels of communication, but it can also be used to provide non-repudiation of actions, basically leaving digital footprints that show someone did something. This means that cryptography allows us to provide authentication, authorization, <em>and</em> accounting (AAA).
					</p>

					<p>
					By using a secure and 
						<em>confidential</em> encrypted channel we can be sure that anyone who intercepts our communications cannot "listen in." This helps prevents 
						<idx>man-in-the-middle</idx><term>man-in-the-middle (MITM)</term> attacks. Cryptography can also be used to provide 
						<em>integrity</em>: proving that the data is valid. With cryptography you can provide a 
						<em>signature</em> for the data showing that the person who claims to have sent it really did send it. Cryptography also allows for 
						<idx>non-repudiation</idx><term>non-repudiation</term> as it can show that only one person was capable of sending a particular message. Lastly cryptography also allows us to perform authentication 
						<em>without</em> storing passwords in plaintext. This is critical in an age where data breaches are increasingly common.
					</p>
				<p>
					<example xml:id="case-study-equifax">
      				<title>Case Study: Equifax</title>
					<p>
						<url href="https://www.ftc.gov/enforcement/cases-proceedings/refunds/equifax-data-breach-settlement">In September of 2017, Equifax announced a data breach the exposed the personal information of 147 million people.</url> The original attack made use of an exploit in an outdated version of 
						<url href="https://struts.apache.org/">Apache Struts</url> which was being used as part of Equifax’s system for handling credit disputes from customers. Once the attackers had gained access to internal Equifax servers, the began gathering as much information as they could from internal databases.
				
					</p>

					<p>
					What is particularly egregious about this data breach is that passwords in many databases were stored in plaintext. This means that the attackers were able to try the passwords and usernames on other services. While it is important that users use different passwords for different services it is far more disturbing that a company as large as Equifax did not have the policies in place to use cryptography to mitigate the risks from such an enormous breach.
				</p>
			</example>
		</p>
				</section>
				<section xml:id="terminology">
					<title>Terminology</title>

					<p>
					Going forward, it is important to address some common cryptography terms as they will be used frequently:
				</p>
					<p><idx>plaintext</idx><term>Plaintext</term>: <url href="https://en.wikipedia.org/wiki/Plaintext">unencrypted information</url>, data that is "in clear", or cleartext.</p>

					<p><idx>cipher</idx><term>Cipher</term>: <url href="https://en.wikipedia.org/wiki/Cipher">an algorithm for performing encryption or decryption.</url></p>

					<p><idx>ciphertext</idx><term>Ciphertext</term>: data that has undergone encryption.</p>

					<p><idx>cryptographic algorithm</idx><term>Cryptographic algorithm</term>: a series of steps to follow to encrypt or decrypt data.</p>

					<p><idx>public key</idx><term>Public key</term>: information (typically a byte array) that can be used to encrypt data such that only the owner of the matching <em>private key</em> can decrypt it.</p>

					<p><idx>private (secret) key</idx><term>Private (secret) key</term>: information (typically a byte array) that can be used to decrypt data encrypted using the corresponding public key.</p>
					
					<example>
					<title>Caesar Cipher</title>
					<p>
					</p>
					<p>
					One of the most basic examples of encryption is the Caesar cipher, or substitution cipher. It is easy to understand, compute, and trivial to crack. Let’s create a table that maps every letter in the alphabet to a different letter:
				</p>
					<table>
						<title></title>
						<tabular>
							<row header="yes">
								<cell halign="left">A</cell>
								<cell halign="left">B</cell>
								<cell halign="left">C</cell>
								<cell halign="left">D</cell>
								<cell halign="left">E</cell>
								<cell halign="left">F</cell>
								<cell halign="left">G</cell>
								<cell halign="left">H</cell>
								<cell halign="left">I</cell>
								<cell halign="left">J</cell>
								<cell halign="left">K</cell>
								<cell halign="left">L</cell>
								<cell halign="left">M</cell>
								<cell halign="left">N</cell>
								<cell halign="left">O</cell>
								<cell halign="left">P</cell>
								<cell halign="left">Q</cell>
								<cell halign="left">R</cell>
								<cell halign="left">S</cell>
								<cell halign="left">T</cell>
								<cell halign="left">U</cell>
								<cell halign="left">V</cell>
								<cell halign="left">W</cell>
								<cell halign="left">X</cell>
								<cell halign="left">Y</cell>
								<cell halign="left">Z</cell>
							</row>
							<row>
								<cell halign="left">J</cell>
								<cell halign="left">G</cell>
								<cell halign="left">T</cell>
								<cell halign="left">Q</cell>
								<cell halign="left">X</cell>
								<cell halign="left">Y</cell>
								<cell halign="left">A</cell>
								<cell halign="left">U</cell>
								<cell halign="left">C</cell>
								<cell halign="left">R</cell>
								<cell halign="left">V</cell>
								<cell halign="left">I</cell>
								<cell halign="left">F</cell>
								<cell halign="left">H</cell>
								<cell halign="left">O</cell>
								<cell halign="left">K</cell>
								<cell halign="left">L</cell>
								<cell halign="left">E</cell>
								<cell halign="left">D</cell>
								<cell halign="left">B</cell>
								<cell halign="left">W</cell>
								<cell halign="left">S</cell>
								<cell halign="left">Z</cell>
								<cell halign="left">M</cell>
								<cell halign="left">N</cell>
								<cell halign="left">P</cell>
							</row>
						</tabular>
					</table>

					<p>
					Now creating a message is simple a matter of performing the substitutions. For example, 
						<c>HELLO WORLD</c> becomes 
						<c>UXIIO ZOEIQ</c>.
					</p>
					<p>
					While this is simple to understand and set up, it is also very easy to break. You could use a frequency attack, where you analyze a large chunk of encrypted text knowing that certain letters are more frequent than others. By matching up the most frequently used ciphertext letters with their standard English equivalents you may quickly reach a solution. You could also go through all permutations of the alphabet (4E26) and see what gives you the most English words. The second attack is made much more feasible through computing.
				</p>
			</example>
				</section>
				<section xml:id="keys">
					<title>Keys</title>
					<p>
					Typically a series of random bytes can be used as a key to either encrypt or decrypt data. A key is used by a cryptographic algorithm to change plaintext to ciphertext. Keys may also be asymmetric in that they can only be used to perform 
						<em>one</em> of the operations (either encryption or decryption).
				
					</p>
					<p>
					It is important to have an idea of what factors make a 
						<em>strong</em> cryptographic key. Length plays an important role. The longer the key, the hard it is to 
						<em>crack</em> the encryption. Likewise the randomness of the data in the key also makes it stronger. If the byte sequence is somehow predictable, the length is irrelevant. Finally we have the concept of a cryptoperiod or lifetime of a key. If we are working with a system that frequently changes keys an attacker may not have enough time to crack it.
				
					</p>
				</section>
				<section xml:id="mathematical-foundation">
					<title>Mathematical Foundation</title>
					<p>
					Cryptography relies largely on the concept of one-way or trap door functions. That is a process that is hard to compute in one direction, but easy to compute in the other. For example it is much easier for a computer to multiply large numbers than to determine the factors of large numbers. This is the foundation of the RSA algorithm. 
						<url href="https://www.cs.drexel.edu/~jpopyack/IntroCS/HW/RSAWorksheet.html">A simplified version of the algorithm</url> is shown below:
				
					</p>

					<program>

KEY GENERATION
p = a random prime number
q = a random prime number
N = p * q
r = (p - 1) * (q - 1)
K = a number which equals one when modded by r and can be factored
e = a factor of K that doesn't share factors with N
d = another factor of K that doesn't share factors with N
Your public key is N and e
Your private key is N and d
					
ENCRYPTION
ciphertext = (cleartext**e)%N

DECRYPTION
cleartext = (ciphertext**d)%N

EXAMPLE
p = 7
q = 13
N = 7 * 13 = 91
r = 72
K = 145 (because 145%72 = 1)
e = 5
d = 29
Public Key = 91, 5
Private Key = 91, 29
cleartext = 72 ('H' in ASCII)
ciphertext = (72**5)%91 = 11 (encrypted using N and e)
cleartext = (11**29)%91 = 72 (decrypted using N and d)

					</program>

					<p>
					In order to 
						<em>crack</em> RSA you would need to be able to factor N into its two prime numbers. While it is trivial in our simple example, imagine how difficult it would be to 
						<url href="https://stackoverflow.com/questions/11832022/why-are-large-prime-numbers-used-in-rsa-encryption">factor a number with 1400 decimal digits,</url> the current recommended keysize for RSA. You’ll notice that the algorithm only requires exponentiation, multiplication, and modulus arithmetic. At no point do you ever have to factor a large prime number to generate keys, encrypt, or decrypt. You only have to perform that operation if you’re trying to work backwards without the keys.
				
					</p>
					<p>
					Other similar one-way function exist based on elliptical curves. It turns out that motion along an elliptical curve can be described according to a start and end point and several iterations of a simple algorithm. You can reconstruct the initial conditions if you know the start point, end point, and how many iterations it took. If all you know is the start and end point you can’t determine the initial conditions.
				</p>
				</section>
				<section xml:id="hashes">
					<title>Hashes</title>
					<figure>
                        <caption></caption>
                        <image source="hash.svg" >
                            <shortdescription>Flowchart showing 'Plain Text' processed by a 'Hash Function' to produce 'Hashed Text'.</shortdescription>
                            <description>
                                <p>The image, captioned 'hash,' is a flowchart illustrating the cryptographic hashing process in three stages from left to right, connected by arrows.</p>
                                <p>The first stage features a document icon labeled 'Plain Text'. An arrow leads to the second stage, a box with an internal grid pattern, labeled 'Hash Function'. A final arrow points to the third stage, a document icon filled with seemingly random characters, labeled 'Hashed Text'.</p>
                                <p>This visual representation demonstrates how a hash function transforms readable plaintext into a non-readable, fixed-size string known as hashed text or a digest.</p>
                            </description>
                        </image>
                    </figure>
					<p><idx>hashing algorithm</idx>
					A <term>hashing algorithm</term> is a one-way function that creates hashed text from plaintext. It is often used for data validation as a relatively small hash 
						<em>digest</em> or 
						<em>signature</em> can demonstrate the integrity of a large block of data. Hashes can also be used so that sensitive information does not have to be stored in cleartext. By storing a hash of a password, you can check to see if the correct password was entered without storing the password itself. In the case of a data breach only the hashes are leaked and the attacker does not have access to the passwords to try with other services.
				
					</p>
					<p>
					Two main families of hash algorithms are used: MD5 and SHA. MD5 produces a 128-bit hash value and is still often used to verify data integrity. The algorithm is technically cryptographically broken, but you may still see it in use. The SHA family of algorithms consists of SHA-1, SHA-2, and SHA-3:
				</p>
					<p>
						<ul>
							<li>
								<p>
										SHA-1: 160 bits, similar to MD5, designed by the NSA, no longer approved for cryptographic use
									</p>
							</li>
							<li>
								<p>
										SHA-2: SHA-256 and SHA-512, very common with the number indicating the block size, designed by the NSA
									</p>
							</li>
							<li>
								<p>
										SHA-3: non-NSA designed, not widely adopted, similar numbering scheme as SHA-2 (SHA3-256, etc.)
									</p>
							</li>
						</ul>
					</p>
					<p>
					Dictionary based attacks against password hashes are fairly common. Typically software is used which generates a hash for every word in the dictionary and then compares that hash to what is stored on the compromised machine. One way to combat this is through salting or adding random bits to each password. When salting the bits are stored with the hash. This forces a dictionary based attack to actively generate the hashes based on what the salt is as opposed to using a stored table (rainbow table) of all the possible hashes. It can make attacks go from instant to days or even years depending on the complexity of the password.
				</p>
					<p>
					An even better way of combating attacks against hashes is through a secret salt or 
						<em>pepper</em>. A pepper is a random value that is added to the password but not stored with the resulting hash. The random value can be stored in a separate medium such as a hardware Security Module.
				
					</p>
				</section>
				<section xml:id="symmetric-encryption">
					<title>Symmetric Encryption</title>
					<figure>
                        <caption></caption>
                        <image source="symmetric.svg" >
                            <shortdescription>Flowchart of symmetric encryption: Plaintext is encrypted with key 'A' to Ciphertext, then decrypted with the same key 'A' back to Plaintext.</shortdescription>
                            <description>
                                <p>The image, captioned 'symmetric,' is a flowchart demonstrating the symmetric encryption process. It displays a sequence of five stages, from left to right, connected by arrows, illustrating data transformation.</p>
                                <p>The process begins with a document icon labeled 'Plaintext'. An arrow points to a key-shaped icon labeled 'A' and also 'Encryption', representing the encryption step with Key A. This transformation results in a document icon labeled 'Ciphertext'. Following this, an arrow points from the ciphertext to the same key-shaped icon, indicating the decryption step. A final arrow leads to a document icon labeled 'Plaintext', signifying the recovery of the original data.</p>
                                <p>This diagram clearly illustrates the core principle of symmetric encryption: the identical key (Key 'A') is utilized for both encrypting the plaintext to ciphertext and subsequently decrypting the ciphertext back to the original plaintext.</p>
                            </description>
                        </image>
                    </figure>
					<p>
					Symmetric encryption is probably the simplest encryption to understand in that it only uses a single key (in this case our key is labelled 'A') to encrypt or decrypt data. Both parties need to know the private key in order to communicate. It does pose a security risk in that if the channel used for key exchange is insecure, all of the messages can be decrypted. That being said, given that it is simpler than many other forms of encryption, it is often used for secure communication or storage.
				</p>
				<example>
                    <title>One-time-pad</title>
                    <p>	
				</p>
					<p>
					One-time-pad (OTP) is a rare example of a pen and paper, symmetric encryption scheme that cannot be cracked. The difficulty in OTP mirrors the difficulty with all symmetric encryption, namely that pre-shared keys need to be exchanged at some point.
				</p>
					<p>
					Imagine that a prisoner wishes to send encrypted messages to someone outside the prison. To do so, they will make use of a copy of Harry Potter and the Sorcerer’s Stone that they have in their cell. The message they want to send is "DIG UP THE GOLD". They turn to "Chapter One: The Boy Who Lived" and look up the first twelve letters in the chapter: MR AND MRS DURS. For each letter of their message, they convert it to its number in the alphabet: 4 9 7 21 16 20 8 5 7 15 12 4 (DIG UP THE GOLD). They do the same for the key they looked up in their book: 13 18 1 14 4 13 18 19 4 21 18 19 (MR AND MRS DURS). Finally they add the two numbers to get their ciphertext: 17 27 8 35 20 33 26 24 11 36 30 23.
				</p>
					<p>
					If the prisoner sends that ciphertext to someone on the outside who knows that they key is the first chapter of Harry Potter and the Sorcerer’s Stone, they will be able to subtract the key from each of the numbers in the ciphertext and discover the plaintext message. While theoretically unbreakable, anybody else who has the key can recover the text as well. This means that using common keys like popular books make it trivial for a man-in-the-middle to decode the ciphertext. After all, the warden probably knows every book that the prisoner has in their cell.
				</p>
					<p>
					OTP has been used by spy agencies, often for communications between individuals via dead-drops. In this situation tables of random characters printed in duplicate are exchanged as the key.
				</p>
				</example>
                </section>
                
				<section xml:id="asymmetric-encryption">
					<title>Asymmetric Encryption</title>
					<figure>
                        <caption></caption>
                        <image source="asymmetric.svg">
                            <shortdescription>Flowchart of asymmetric encryption: Plaintext is encrypted with a 'Public' key to Ciphertext, then decrypted with a 'Private' key back to Plaintext.</shortdescription>
                            <description>
                                <p>The image, captioned 'asymmetric,' is a flowchart that visually explains the process of asymmetric encryption. It displays a sequence of five stages from left to right, connected by arrows, illustrating data transformation using a public and private key pair.</p>
                                <p>The process begins with a document icon labeled 'Plaintext'. An arrow points to a key-shaped icon explicitly labeled 'Public' (and also 'Encryption'), representing encryption with the public key. This transforms the data into a document icon labeled 'Ciphertext'. From the ciphertext, another arrow points to a different key-shaped icon explicitly labeled 'Private' (and also 'Decryption'), representing decryption with the private key. A final arrow leads to a document icon labeled 'Plaintext', showing the original data successfully recovered.</p>
                                <p>This diagram clearly illustrates the core principle of asymmetric encryption: a public key is used for the encryption process, and its corresponding, distinct private key is required for the decryption process, ensuring that only the intended recipient holding the private key can access the original plaintext.</p>
                            </description>
                        </image>
                    </figure>
					<p>
					An asymmetric encryption algorithm has actually already been demonstrated in the 
						<xref ref="mathematical-foundation">Mathematical Foundation</xref> section. Asymmetric encryption has a public key which can be published anywhere and used to encrypt messages that only the holder of the private key, which is not published, can unencrypt. For example if you want to receive encrypted emails you may make your 
						<url href="https://gnupg.org/">GNU Privacy Guard (GPG)</url> public key available a 
						<url href="https://keyserver.ubuntu.com/">public key server</url>. This would allow anyone to look up your public key, encrypt a message that only you can read, and send you the ciphertext. Asymmetric encryption gets around the difficulties of key exchange via an untrusted channel (like email). Unfortunately the cost of such a useful system is that asymmetric algorithms tend to be much slower that their symmetric counterparts.
				
					</p>
				</section>
				<section xml:id="stream-ciphers">
					<title>Stream Ciphers</title>
					<p>
					Stream ciphers encode data one symbol at a time and produces one ciphertext symbol for each cleartext symbol. Given that you can often use some sort of block encryption with a significantly small block size, stream encryption is not used as often. Technically the OTP example, when used one symbol at a time, is a stream cipher. The keys come in one symbol at a time, the cleartext comes in one symbol at a time, and an operation is performed (addition in the case of the example) to create the ciphertext. Given a suitable keysize and a well-researched algorithm, stream ciphers can be just as secure as block ciphers. That being said a stream cipher is usually more consistent in its runtime characteristics and typically consumes less memory Unfortunately there are not as many well-researched algorithms and widely used stream ciphers.
				</p>
				</section>
				<section xml:id="block-ciphers">
					<title>Block Ciphers</title>
					<introduction>
					<p>
					Block ciphers takes the data in, in blocks and use cipher blocks of the same size to perform the encryption. It is very popular and there are many secure algorithms to choose from. Unfortunately if the input data doesn’t fit neatly into blocks of the same size, padding may be required, which takes up more space/memory and reduces the speed of the cipher. As such the block encryption is often less performant than stream encryption.
				</p>
					</introduction>
					<subsection xml:id="block-cipher-modes-of-operation">
						<title>Block Cipher Modes of Operation</title>
						<introduction>
						<p>
						There are several ways you can create your cipher blocks and depending on how you do it, various attacks are possible:
						</p>
						</introduction>
						<subsubsection xml:id="electronic-codebook-ecb">
							<title>Electronic Codebook (ECB)</title>

							<figure>
                                <caption></caption>
                                <image source="ecb.svg">
                                    <shortdescription>Diagram showing Electronic Codebook (ECB) mode encryption where multiple plaintext blocks are independently encrypted with the same key.</shortdescription>
                                    <description>
                                        <p>The image, captioned 'ecb' and also titled 'Electronic Codebook (ECB) mode encryption' below the diagram, illustrates how ECB mode operates on multiple blocks of plaintext.</p>
                                        <p>It displays three identical, parallel encryption processes. In each instance, a 'Plaintext' block, represented as a sequence of conjoined squares, is shown as input to a rectangular unit labeled 'block cipher encryption'. A 'Key' is also depicted as an input to this encryption unit. The output from each encryption unit is a 'Ciphertext' block, similarly represented as a sequence of conjoined squares.</p>
                                        <p>This visual arrangement emphasizes that each block of plaintext is encrypted independently of other blocks, using the same key for every block. A key characteristic highlighted by this method is that identical plaintext blocks will result in identical ciphertext blocks.</p>
                                    </description>
                                </image>
                            </figure>
							<p>
								<url href="https://commons.wikimedia.org/wiki/File:ECB_encryption.svg">WhiteTimberwolf (SVG version)</url>, Public domain, via Wikimedia Commons
							</p>
							<p>
							The simplest mode of operation, data is divided into blocks and each block is encoded using a key. Since the blocks are encoded the same way, identical blocks will give identical ciphertexts. This makes it easier, given enough data, to determine what the key is.
						</p>
						</subsubsection>
						<subsubsection xml:id="cipher-block-chaining-cbc">
							<title>Cipher block chaining (CBC)</title>

							<figure>
                                <caption></caption>
                                <image source="cbc.svg">
                                    <shortdescription>Diagram of Cipher Block Chaining (CBC) mode of block cipher encryption.</shortdescription>
                                    <description>
                                        <p>The diagram, captioned 'cbc,' illustrates the Cipher Block Chaining (CBC) mode of operation for block ciphers. It typically shows plaintext blocks being processed sequentially.</p>
                                        <p>An Initialization Vector (IV) is depicted being XORed with the first plaintext block before it undergoes encryption with the key. For all subsequent blocks, the ciphertext generated from the encryption of the *previous* block is shown being XORed with the current plaintext block before it is encrypted. This chaining dependency is a key visual feature, ensuring that identical plaintext blocks produce different ciphertext blocks.</p>
                                    </description>
                                </image>
                            </figure>
							<p>
								<url href="https://commons.wikimedia.org/wiki/File:CBC_encryption.svg">WhiteTimberwolf (SVG version)</url>, Public domain, via Wikimedia Commons
						
							</p>
							<p>
							Starting with an initialization vector (IV) each block is XORed with part of the ciphertext of the previous block to create a chain of ciphertext that is constantly changing. This means that identical blocks will result in 
								<em>different</em> ciphertexts. This is the most common mode of operation, its weaknesses being that the algorithm cannot be run in parallel (sorry modern processors) and that the IV is a common attack target.
							</p>
						</subsubsection>
						<subsubsection xml:id="counter-ctr-_counter_ctr">
							<title>Counter (CTR)</title>
							<figure>
                                <caption></caption>
                                <image source="ctr.svg">
                                    <shortdescription>Diagram illustrating Counter (CTR) mode encryption with nonce and incrementing counter per block.</shortdescription>
                                    <description>
                                        <p>The image, captioned 'ctr' and also titled 'Counter (CTR) mode encryption' below the diagram, illustrates the Counter (CTR) mode of block cipher operation. It shows three parallel examples of encrypting a plaintext block, each with an incrementing counter value.</p>
                                        <p>In each depicted instance, a 'Nonce' (e.g., 'c59bcf35...') is combined with a 'Counter' (sequentially '0000000', '0000001', '0000002'). This combined value is input to a 'block cipher encryption' unit, along with a 'Key'. The encrypted output of this unit is then XORed (symbolized by ⊕) with a 'Plaintext' block to produce the corresponding 'Ciphertext' block.</p>
                                        <p>The diagram highlights that the same nonce is used for these blocks while the counter value increments for each, a mechanism that allows for parallel encryption of blocks. The generation of the keystream (encrypted nonce-counter) is shown as distinct from its application to the plaintext via XOR.</p>
                                    </description>
                                </image>
                            </figure>
							<p>
								<url href="https://commons.wikimedia.org/wiki/File:CTR_encryption_2.svg">WhiteTimberwolf (SVG version)</url>, Public domain, via Wikimedia Commons
							</p>
							<p>
							Instead of using an IV, CTR uses a nonce (random number that is the same for all blocks) and counter. The counter is incremented with each block, meaning this mode can function in parallel. CTR mode solves the problems of ECB while still providing an algorithm that can run quickly on modern machines.
							</p>
						</subsubsection>
						<subsubsection xml:id="galoiscounter-mode-gcm">
							<title>Galois/Counter Mode (GCM)</title>
							<figure>
                                <caption></caption>
                                <image source="gcm.svg" >
                                    <shortdescription>Diagram of Galois/Counter Mode (GCM) showing parallel encryption via CTR and authentication tag generation.</shortdescription>
                                    <description>
                                        <p>The image, captioned 'gcm' and titled 'Galois/Counter Mode (GCM)', details an authenticated encryption mode. It illustrates an Initialization Vector (IV) used with a series of incrementing counters (Counter 0, Counter 1, Counter 2). Each counter is encrypted with a key (E<sub>K</sub>). This encrypted counter output is then XORed with corresponding Plaintext blocks (Plaintext 1, Plaintext 2) to produce Ciphertext blocks (Ciphertext 1, Ciphertext 2), demonstrating the Counter (CTR) mode portion of GCM.</p>
                                        <p>In parallel, the diagram shows the authentication mechanism. Authenticated Data (Auth Data 1) and the generated Ciphertext blocks are processed through several Galois field multiplication steps (mult<sub>H</sub>). The lengths of the authenticated data and ciphertext (len(A) || len(C)) are also included in this process. The cumulative result is XORed with the encrypted output of the first counter (E<sub>K</sub>(Counter 0)) to generate the final 'Auth Tag'.</p>
                                        <p>This diagram effectively visualizes how GCM combines CTR mode for encryption with a GHASH function for authentication, thereby providing both data confidentiality and integrity.</p>
                                    </description>
                                </image>
                            </figure>
							<p>
								<url href="https://commons.wikimedia.org/w/index.php?curid=74845777">Gallois Counter Mode block diagram with initialization vector, adapted from a diagram by NIST
								</url> is used under 
								<url href="https://creativecommons.org/publicdomain/zero/1.0/deed.en">CC0 1.0</url>
							</p>
							<p>
							GCM uses a counter like CTR, but does not make use of a nonce. Instead an IV is used with the inititial counter. GCM also generates a message authentication code (MAC) for each block to verify the integrity of the block. This combination makes for a modern, robust algorithm that is gaining rapid adoption.
							</p>
					
							<example>
							<title>Case Study: Exploiting Non-Rolling Codes</title>
							<p>
							The importance of non-repeating codes, such as the counter codes used in the CTR and GCM block cipher modes of operation can be highlighted through analysis of another important technology that uses codes: keyless entry systems. When garage door openers first came on to the market, the remote would broadcast a single code that the receiver was programmed to recognize as correct. This meant that anyone listening in could easily get the code and replay the code to open the garage door with their own device. (<em>In actuality the code space was so small that you could even easily create a device to cycle through all possible codes in under a minute.</em>)
							</p>
							<p>
							To combat this, companies began using 
							<url href="https://en.wikipedia.org/wiki/Rolling_code">rolling codes</url> in their remotes and receivers. Given the same seed a rolling code allows each device to generate a sequence of codes that are exactly the same. The remote will use the next code in a sequence every time the button is hit. The receiver will validate the recieved code if it matches any of the next several codes in the sequence (in case the button was hit a few times out of range). This effectively mitigates the replay attack.
		
							</p>
							<p>
							Given that this was implemented in the 1980s with garage door remotes, you would assume car manufacturers employ the same technology in their remotes. In a case of "everything old is new again" this isn’t true. 
								<url href="https://github.com/HackingIntoYourHeart/Unoriginal-Rice-Patty/blob/main/README.md">Blake Berry (HackingIntoYourHeart) discovered that several makes and models of cars are actually still vulnerable to a replay attack.</url>
							</p>
							<p>
							Sammy Kamkar also discovered a vulnerablility for rolling codes, named RollJam, which he demonstrated at DEF CON 23. Kamkar’s device jams signals sent by a keyfob, while recording the codes being sent. Once it has two codes recorded, presumably from the victim pressing the button multiple times, it stops jamming, sends out the first code to unlock the car and stores the second code to unlock the car at a later time.
						</p>
							</example>
							</subsubsection>
						</subsection>

				</section>
				<section xml:id="encryption-examples">
					<title>Encryption Examples</title>
					<subsection xml:id="rsa">
						<title>RSA</title>
						<p>
						RSA is an asymmetric encryption standard developed in 1977 that is still very popular. Its trapdoor function is based on the difficulty of factoring large numbers. The name RSA comes from the names of the authors of the system: Ron Rivest, Adi Shamir, and Leonard Adleman.
					</p>
					</subsection>
					<subsection xml:id="advanced-encryption-standard-aes">
						<title>Advanced Encryption Standard (AES)</title>
						<p>
						AES is a symmetric block cipher developed in 1998 to supersede the less secure Data Encryption Standard (DES). AES works on 128 bit blocks of data, performing multiple rounds of substitution-permutation to encrypt data. You will find AES used to encrypt network traffic (as is the case in a virtual private network), data stored to disk (disk encryption), or computer game data that is saved to storage. AES is a 
							<em>very</em> common cipher.
					
						</p>
					</subsection>
					<subsection xml:id="elliptic-curve-cryptography-ecc">
						<title>Elliptic-curve Cryptography (ECC)</title>
						<p>
						ECC is an asymmetric encryption scheme that is quite fast and easy to computer. It is rapidly becoming the go to choice for digital signatures and key exchanges, gaining adopting starting in 2004. ECC is based on the geometry of a pre-determined set of curves (some examples can be found 
							<url href="http://www.secg.org/sec2-v2.pdf">here</url>), which can be used to create a trapdoor function.
					
						</p>
					</subsection>
					<subsection xml:id="diffie-hellman-key-exchange">
						<title>Diffie-Hellman Key Exchange</title>
						<figure>
                            <caption></caption>
                            <image source="dh.svg">
                                <shortdescription>Diagram illustrating Diffie-Hellman key exchange using the paint mixing analogy with Alice and Bob.</shortdescription>
                                <description>
                                    <p>The image, captioned 'dh' and also titled 'Diffie-Hellman Key Exchange' (or similar, based on context from image analysis), clearly illustrates the protocol using the well-known paint mixing analogy. It involves two parties, labeled Alice on the left and Bob on the right.</p>
                                    <p>Both Alice and Bob begin with a canister of 'Common paint' (depicted as yellow). Each then separately mixes this common paint with their own unique 'Secret colours': Alice uses an orange paint, and Bob uses a blue-green paint. This step results in two distinct mixed paint colors, one for Alice (an orange-yellow mixture) and one for Bob (a blue-yellow mixture).</p>
                                    <p>These new mixtures are then shown being exchanged via 'Public transport', indicated by arrows crossing between Alice and Bob. After the exchange, Alice adds her original secret orange paint to the mixture received from Bob. Similarly, Bob adds his original secret blue-green paint to the mixture received from Alice. Both processes are depicted to culminate in the same final 'Common secret' paint color (a brownish hue).</p>
                                    <p>A note within the diagram, '(assume that mixture separation is expensive)', underscores the cryptographic principle that the combined values are difficult to reverse-engineer to find the original secret components.</p>
                                </description>
                            </image>
                        </figure>
						<p>
							<url href="https://commons.wikimedia.org/wiki/File:Diffie-Hellman_Key_Exchange.svg">Original schema: A.J. Han Vinck, University of Duisburg-EssenSVG version: Flugaal</url>, Public domain, via Wikimedia Commons
					
						</p>
						<p>
						Given the slow nature of asymmetric algorithms, often an application such as a VPN will choose to use asymmetric cryptography to exchange a shared secret key and then use that secret key with a faster symmetric algorithm such as AES. Diffie-Hellman does exactly that and was first published in 1976. Diffie-Hellman key exchange uses the same mathematical concepts as RSA, exponentiation and modulus arithmetic, to great effect, but to visualize what is happening a metaphor of secret color mixing is used (see the included diagram). It is important to remember that because the medium of exchange may be slow a DH key exchange is designed to generate minimal traffic.
					</p>
					</subsection>
					<subsection xml:id="digital-certificates">
						<title>Digital Certificates</title>
						<p>
						A digital certificate is a set of credentials used to identify a company or an individual. Since asymmetric encryption requires know a party’s public key, a digital certificate includes that key as well as an ID of the owner. The question then becomes how do you trust that the public key is 
							<em>actually</em> for the alleged owner? That’s where the issuing authority comes in. A 
							<em>certificate authority (CA)</em> signs the certificate indicating that the ID and public_key are correct. Certificates can be self-signed, but this sidesteps the trust placed in the CA and is often only used in testing. Since most certificates are used for encrypting web traffic, Web browsers will typically warn you if a site is using a self-signed certificate.
					
						</p>
						<p>
						Given how how many certificates need to be issued and the work that needs to be done to verify them, most certs are not issues by root CAs, but are actually issued by intermediate CAs. Root CAs delegate the work to Intermediate CAs and indicate their trust in them by signing the intermediate CAs keys. This creates a 
							<em>chain of trust</em> from the issued certificate (signed by the Intermediate CA) to the Intermediate CA (signed by the root CA) to the root CA (trusted by the browser). Tools that use this chain of trust will keep the root CA certificates and update them from the companies that issue them as needed.
					
						</p>
						<p>
						The certificate store is very important and while users rarely interact with it is often possible to install root CAs manually. 
							<url href="https://docs.telerik.com/fiddler/configure-fiddler/tasks/trustfiddlerrootcert">This is can be used to create a proxy that can decrypt HTTPS traffic for debugging</url> or for more nefarious purposes. For this reason some applications, Facebook mobiles apps for example, maintain their own certificate store and prevent users from adding root CAs to it.
					
						</p>
						<p>
							<url href="https://letsencrypt.org/">
								<image source='letsencrypt.svg'/>
							</url>
						</p>
						<p>
						So how do you get a certificate for your website? The customer will generate a Certificate Signing Request (CSR) that includes the public key and their ID. The CA will validate that the customer owns the website and build and sign the cert. This whole process can be automated and performed for free via a tool called 
							<url href="https://letsencrypt.org/">Let’s Encrypt</url>.
					
						</p>
					</subsection>
					<subsection xml:id="blockchain">
						<title>Blockchain</title>
						<figure>
							<caption></caption>
							<image source="btc.svg" decorative="yes"/>
						</figure>
						<p>
							<url href="https://commons.wikimedia.org/wiki/File:Bitcoin_logo.svg">Bitboy</url>, Public domain, via Wikimedia Commons
					
						</p>
						<p>
						It is hard to talk about cryptography without addressing blockchains, one of the concepts behind cryptocurrencies. A blockchain is a shared ledger (of transactions in the case of BitCoin) where blocks are constantly being added to add to the information being stored. Periodically an new block is created, which includes a hash of the previous block and a hash of itself for the next block to reference. By examining these hashes, you can prove the integrity each block and its position, thus making a publicly-available, mutually agreed upon accounting of what has occurred on the network. Typically to prevent bad actors from adding block some sort of proof of work, a mathematically difficult operation, or proof of stake, an accounting of investment in the network, must be included when adding a block to the chain.
					</p>
					</subsection>
					<subsection xml:id="trusted-platform-module-tpm">
						<title>Trusted Platform Module (TPM) / Hardware Security Module (HSM)</title>
						<p>
						These modules provide hardware specifically for use with encryption. HSMs are removable modules while TPMs are motherboard chips. Many ciphers rely on a reliable source of entropy (randomness) which these modules provide. They can also significantly increase the speed at which cryptographic algorithms run by moving the operations to specialized hardware. Lastly, these modules can be used to store keys 
							<em>and</em> make them only accessible via the module. This can add an extra layer of security to prevent the keys from being easily copied.
					
						</p>
					</subsection>
					<subsection xml:id="steganography">
						<title>Steganography </title>
						<p>
						Steganography is the process of hiding data in something such that to a casual observer it cannot be detected. Data can be hidden in audio, images, or even 
							<url href="https://dl.packetstormsecurity.net/crypt/snow/description.html">plain text!</url>. The hidden data can also be encrypted if an additional layer of security is required. In the field of security, malicious code may be hidden inside other files using steganographic techniques. This makes it more difficult for tools to find them when searching storage.
					
						</p>
					</subsection>
				</section>
				<section xml:id="lab-hash-it-out">
					<title>Lab: Hash it Out</title>
					<p><idx>hash</idx> 
					A 
						<term>hash</term> is a one-way cryptographic function that produces a 
						<em>unique</em> set of characters for a given 
						<em>message</em>. In a perfect world, given a hash you should 
						<em>not</em> be able to determine what the original message was, but given a hash and the original message you can check that the hash matches the message. Before we dive into the uses of a hash, lets try to further understand it by looking at a simple and consequently poor hashing algorithm.</p>
						<note><p>The following algorithm is so poor that it may be a stretch even to call it a hashing algorithm. That being said, it is being used as a tool to explain what hashes are.</p></note>
					<p>
						<term>Anagram Hash</term>
					</p>
					<p>
					Let’s assume we wanted to hash the message "Hello from Karl" so that we can have a string of characters the uniquely represent that phrase. One way to do it would be to strip all the punctuation in the message, make everything lowercase, and then arrange all the letters alphabetically. "Hello from Karl" becomes "aefhklllmoorr". You can think of it like saying, "There is one 'a' in the message, one 'e' in the message, one 'f' in the message', one 'k' in the message, three 'l’s in the message…​" Now our hash, "aefhklllmoorr", can be used to uniquely identify the phrase.
				</p>
					<p>
					Now assume Karl wants to send us a message but he can’t trust the person sending the message. He could use the untrusted party to send us the message and then put the hash someplace public like on a website. We could use the hash to know the message came from Karl 
						<em>and</em> if anyone else got the hash they would not be able to discern the message because a hash is a one-way function. "aefhklllmoorr" reveals very little about the message, but it can be used to check its accuracy.
				
					</p>
					<p>
					Hopefully this is beginning to show the power of hashes. Now lets examine another very common usecase and find out exactly why this is a terrible algorithm.
				</p>
					<p>
					Assume you run a website where a user uses a password to log in. You want to make sure users are using their password when they log in, but you do not want to store the password on your website. This is quite common. If you website was breached you don’t want to leak a bunch of people’s passwords. What do you do? What you could do is store a hash of their password, hash the password when they try to login, and compare the hashes. For example if our password was "password" using our basic hash algorithm the hash would be "adoprssw". We could store "adoprssw" in our database, use it for comparison during login, and if someone were to ever steal the data in our database they wouldn’t know that the original password is "password". This may prevent an attacker from exploiting the fact that many people use the same password on multiple sites.
				</p>
					<p>
					The problem is that there are many things that hash to "adoprssw" including "wordpass", "drowsaps", or even the hash we’re storing: "adoprssw". When multiple messages have the same hash it is referred to as a 
						<em>collision</em> and this particular algorithm is useless because it generates so many of them.
				
					</p>
					
                    <question><p>What would the anagram hash of "AlwaysDancing" be?</p></question>
						<p>
					Now that we understand what hashes do and to some extant how they are possible, lets look at a much more useful hash function.
				</p>
					<p>
						<term>MD5</term>
					</p>
					<p>
					For this section, we are going to be using Docker and a terminal. 
						<url href="https://docs.docker.com/get-docker/">Please follow these directions for installing Docker.</url> For Windows you can use the 
						<url href="https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701">Windows Terminal app</url> and in MacOS you can use the preinstalled Terminal app. Gray boxes show the commands as typed into the terminal with typical output where possible. Your prompt (the part shown before the command) may differ depending on your OS.
				
					</p>
					<p>
					Start by running a BASH shell on a custom Linux container:
				</p>
					<pre>ryan@R90VJ3MK:/windir/c/Users/rxt1077/it230/docs$ docker run -it ryantolboom/hash (1)
root@8e0962021f85:/(2)</pre>
					<table>
						<title></title>
						<tabular>
							<row>
								<cell halign="left">
									<term>1</term>
								</cell>
								<cell halign="left">Here we are using the Docker run command interactively (-it) as this container runs bash by default</cell>
							</row>
							<row>
								<cell halign="left">
									<term>2</term>
								</cell>
								<cell halign="left">Notice the new prompt showing that we are root on this container</cell>
							</row>
						</tabular>
					</table>
					<p>
					MD5 is a message-digest algorithm that produces significantly better hashes than our Anagram algorithm. Most Linux distributions include a simple utility for creating an MD5 hash based on a file’s contents. This command is named md5sum. Typically this is used to detect if a file has been tampered with. A website may provide links to download software as well as an MD5 hash of the files so that you know what you’ve downloaded is correct. Similarly a security system may keep md5sums (MD5 hashes) of certain critical files to determine if they have been tampered with by malware. Let’s practice taking the md5sum of the 
						<c>/etc/passwd</c> file:
				
					</p>

					<pre>root@8e0962021f85:/# md5sum /etc/passwd
9911b793a6ca29ad14ab9cb40671c5d7  /etc/passwd (1)</pre>

					<table>
						<title></title>
						<tabular>
							<row>
								<cell halign="left">
									<term>1</term>
								</cell>
								<cell halign="left">The first part of this line is the MD5 hash, the second part is the file name</cell>
							</row>
						</tabular>
					</table>
					<p>
					Now we’ll make a file with 
						<em>your</em> first name in it and store it in /tmp/name.txt:
				
					</p>
					<pre>root@8e0962021f85:/# echo "&lt;your_name&gt;" &gt;&gt; /tmp/name.txt (1)</pre>
					<table>
						<title></title>
						<tabular>
							<row>
								<cell halign="left">
									<term>1</term>
								</cell>
								<cell halign="left">Substitute your actual first name for &lt;your_name&gt;</cell>
							</row>
						</tabular>
					</table>
					
                    <question>
                    <p>
                      What is the md5sum of <c>/tmp/name.txt</c>?
                    </p>  
                    </question>
					<p>
					For our final activity, lets take a look at some of the weaknesses of hashes.
				</p>
					<p>
						<term>Hash Cracking</term>
					</p>
					<p>
					Passwords in a Linux system are hashed and stored in the 
						<c>/etc/shadow</c> file. Let’s print out the contents of that file to see how it looks:
				
					</p>
					<pre>root@7f978dd90746:/# cat /etc/shadow
root:*:19219:0:99999:7:::
daemon:*:19219:0:99999:7:::
bin:*:19219:0:99999:7:::
sys:*:19219:0:99999:7:::
sync:*:19219:0:99999:7:::
games:*:19219:0:99999:7:::
man:*:19219:0:99999:7:::
lp:*:19219:0:99999:7:::
mail:*:19219:0:99999:7:::
news:*:19219:0:99999:7:::
uucp:*:19219:0:99999:7:::
proxy:*:19219:0:99999:7:::
www-data:*:19219:0:99999:7:::
backup:*:19219:0:99999:7:::
list:*:19219:0:99999:7:::
irc:*:19219:0:99999:7:::
gnats:*:19219:0:99999:7:::
nobody:*:19219:0:99999:7:::
_apt:*:19219:0:99999:7:::
karl:$y$j9T$oR2ZofMTuH3dpEGbw6c/y.$TwfvHgCl4sIp0b28YTepJ3YVvl/3UyWKeLCmDV1tAd9:19255:0:99999:7::: (1)</pre>
					<table>
						<title></title>
						<tabular>
							<row>
								<cell halign="left">
									<term>1</term>
								</cell>
								<cell halign="left">As you can see here the 
									<c>karl</c> user has a long hash immediately after their username
								</cell>
							</row>
						</tabular>
					</table>
					<p>
					One of the problems with hashes are that if people choose simple passwords, they can be easily cracked by a program that takes a wordlist of common passwords, generates their hashes, and then checks to see if the hash is the same. While a hash may be a one-way function, it is still subject to this type of attack. We’re use a program called 
						<url href="https://www.openwall.com/john/">John the Ripper</url> and do exactly that.
				
					</p>
					<p>
					John the Ripper is already installed on this container along with a simple wordlist. We will tell it to use the default wordlist to try and determine what the password is that matches karl’s hash in 
						<c>/etc/shadow</c>:
				
					</p>
					<pre>root@8e0962021f85:/# john --format=crypt --wordlist=/usr/share/john/password.lst /etc/shadow
Loaded 1 password hash (crypt, generic crypt(3) [?/64])
Press 'q' or Ctrl-C to abort, almost any other key for status
&lt;karl's password&gt;             (karl)
1g 0:00:00:01 100% 0.6211g/s 178.8p/s 178.8c/s 178.8C/s lacrosse..pumpkin
Use the "--show" option to display all of the cracked passwords reliably
Session completed</pre>
					
            <note>
                <p>Once john has cracked a password it will not show it if you run it again. To 
				    <em>show</em> the passwords that have already been cracked you must run the 
					<c>--show</c> command with the file: 
					<c>john --show /etc/shadow</c>
                </p>    
            </note>
					<p>
					Given that the password is in the included common password wordlist, 
						<c>/usr/share/john/password.lst</c>, you will quickly find that John the Ripper figures out that karl’s password. John the Ripper can also run incrementally though all the possible character combinations, but it takes much longer. To help make these types of attacks more difficult, every hash in 
						<c>/etc/shadow</c> is built off of a random number. This number is called a 
						<em>salt</em> and is stored with the hash. This means that instead of just trying one hash for each word in the wordlist, the hash cracker must try every possible salt for every word in the wordlist, slowing things down significantly. Modern hash crackers may use 
						<url href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow tables</url> so that all of the possible hashes have already been computed. These tables may take up terabytes of disk space, but can make cracking even complicated hashes much simpler.
				
					</p>
					<p>
					Let’s use a custom utility named 
						<c>`crypt</c> to show that we have the actual password. This utility is already installed on your container. We will start by printing out just the line in 
						<c>/etc/shadow</c> that has karl’s info. We will use the 
						<c>grep</c> command to limit out output to things that have 
						<c>karl</c> in them:
				
					</p>
					<pre>root@7f978dd90746:/# cat /etc/shadow | grep karl
karl:$y$j9T$oR2ZofMTuH3dpEGbw6c/y.$TwfvHgCl4sIp0b28YTepJ3YVvl/3UyWKeLCmDV1tAd9:19255:0:99999:7:::</pre>
					<p>
					The first part of the shadow line is the username, karl. The next part of the shadown line, immediately following the first colon, is the hash information. The characters in between the first set of 
						<c>$</c> is the version of the hashing algorithm being used, 
						<c>y</c> for yescrypt in our case. The characters in between the second set of 
						<c>$</c> are the parameters passed to yescrypt which will always be 
						<c>j9T</c> for us. The characters in between the third set of 
						<c>$</c> is your salt. Finally the characters in between the fourth set of 
						<c>$</c> is the hash.
				
					</p>
					<p>
					The [
						<c>crypt</c>] utility calls the system 
						<url href="https://man7.org/linux/man-pages/man3/crypt.3.html">
							<c>crypt</c>
						</url> command and prints the output. Let’s run this utility with the password we’ve cracked and the first three parts of the hash information from 
						<c>/etc/shadow</c>. If everything goes well, you should see hash output that matches what is in 
						<c>/etc/shadow</c>:
				
					</p>
					<pre>root@7f978dd90746:/# crypt &lt;karl's password&gt; '$y$j9T$oR2ZofMTuH3dpEGbw6c/y.' (1)
$y$j9T$oR2ZofMTuH3dpEGbw6c/y.$TwfvHgCl4sIp0b28YTepJ3YVvl/3UyWKeLCmDV1tAd9</pre>
					<table>
						<title></title>
						<tabular>
							<row>
								<cell halign="left">
									<term>1</term>
								</cell>
								<cell halign="left">Don’t forget to use the actual password you cracked and put the hash info in single quotes</cell>
							</row>
						</tabular>
					</table>
					
                    <question><p>Submit a screenshot with your lab showing that the output of the
						<c>crypt</c> command matches the hash in /etc/shadow</p></question>

				</section>
				<section xml:id="cryptography-review">
					<title>Review Questions</title>
					<p>
						<ol>
							<li>
								<p>
									<em>What is the difference between symmetric and asymmetric encryption? Give one common use case for each.</em>
								</p>
							</li>
							<li>
								<p>
									<em>What is a hash and what is it used for? How are hashes used in a blockchain?</em>
								</p>
							</li>
							<li>
								<p>
									<em>What is the difference between a stream cipher and a block cipher? Give one common use case for each.</em>
								</p>
							</li>
						</ol>
					</p>
				</section>
</chapter>