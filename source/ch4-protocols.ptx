<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="ch4-protocols" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Protocols</title>

				<section xml:id="network-access-layer">
					<title> Network Access Layer</title>
						  <introduction>
				<p><idx>protocol</idx>
				A <term>protocol</term> is a set of rules. Protocols in computing are typically thorough rules that dictate communication. A protocol may include information about the syntax used, error correction, synchronization, or any other aspect of how communication occurs in the context of that situation. In computer security it is important to have a thorough understanding of common protocols as their weaknesses often determine how and if an attack will occur. Protocols exist for both hardware and software and have been developed via individuals and organizations. Early networking protocols were often developed on mailing lists using Requests for Comments (RFCs). You may still see RFCs being crafted, referred to, or actively worked on. 
					<url href="https://datatracker.ietf.org/doc/html/rfc2616">Some of the earliest web protocols are detailed in RFCs.</url> More often than not, large protocols have working groups and associations developing, such as the 802.11 group at the 
					<url href="https://www.ieee.org/">Institute of Electrical and Electronics Engineers (IEEE)</url> which handles WiFi protocols. These groups publish papers detailing how the protocols work.
			
				</p>
				<p>
				This chapter will give a brief description of important protocols following the TCP/IP layering model. It is important to note that some of these protocols may reach across layers to accomplish tasks. In this case they will be grouped according to which layer they largely function within.
			</p>
  </introduction>
					<subsection xml:id="arp">
						<title>ARP</title>

						<p><idx>ARP</idx><idx>address resolution protocol</idx>
						<term>Address Resolution Protocol</term> (<term>ARP</term>) is used on the local ethernet segment to resolve IP addresses to MAC addresses. Since this protocol functions at the ethernet segment level, security was not a primary concern. Unfortunately this means that ARP communications can be easily spoofed to cause a MitM scenario. A malicious actor simply sends out several ARP packets, 
							<em>gratuitous ARP</em>, saying that traffic for a certain IP address should be sent to them. Since the MAC to IP address table is cached in several places, it can take a long time for all the caches to invalidate and resolve an issue caused by malicious ARP frames.

					
						</p>

						<p>

							<idx>DAI</idx><idx>dynamic ARP inspection</idx>

						There is a protocol designed to mitigate the issues with ARP. 
						<term>Dynamic ARP Inspection</term> (<term>DAI</term>) reaches across layers to work with the DHCP lease database and drop packets that are not using the MAC address used when a DHCP lease was granted. While this can solve many of the issues associated with ARP it is also a good practice to use secure higher-level protocols such as HTTPS just in case.
					</p>
					</subsection>
					<subsection xml:id="wifi">
						<title>Wifi</title>

						<p><idx>wifi protocols</idx>
						The <term>Wifi protocols</term> we are most concerned with are the security standards used to encrypt data. By the nature of a wireless protocol, information sent on the network is available to anyone with an antenna. These Wifi security standards are the only thing protecting your network traffic from being viewing by anyone within your transmitting range. There are currently four standards:
					</p>
						<ul>
							<li>
								<p><idx>WEP</idx><idx>wireless equivalent privacy</idx>

						<term>Wireless Equivalent Privacy</term> (<term>WEP</term>) is depreceated and should not be used. It was developed in 1999 and uses an RC4 stream and 24-bit encryption. Several attacks have been developed that can crack WEP within a matter of seconds.
					</p>
					</li>
					<li>
						<p><idx>WPA</idx><idx>TKIP</idx><idx>temporal key integrity protocol</idx><idx>WPA</idx><idx>Wifi protected access</idx>
						<term>Wifi Protected Access</term> (<term>WPA</term>) utilized 
						<term>Temporal Key Integrity Protocol</term> (<term>TKIP</term>) to change the keys being used. This 128-bit encryption method has also been cracked and the protocol should not be used.
					</p>
					</li>
					<li>
					<p><idx>WPA2</idx>
						<term>Wifi Protected Access 2</term> (<term>WPA2</term>) makes use of AES encryption and is currently the most popular standard. WPA2 is still considered secure.
					</p>
					</li>
					<li>
						<p><idx>WPA3</idx>
						<term>Wifi Protected Access 3</term> (<term>WPA3</term>) was developed in 2018 and is currently considered state-of-the-art. Many networks are beginning the transition from WPA2 to WPA3.
					</p>
					</li>
					</ul>
					</subsection>
				</section>
				<section xml:id="internet-layer-protocols">
					<title>Internet Layer Protocols</title>


					<subsection xml:id="ip">
						<title>IP</title>

						<p>
							<idx>IP</idx><idx>internet protocol</idx> 
						<term>IP</term> stands for <term>internet protocol</term> and it was devised to allow creating a network of networks. The network of networks that uses it primarily is the Internet, although you could use IP in other scenarios as well. IP is largely concerned with 

							<em>routing</em> traffic across and to networks. The protocol was first detailed by the IEEE in 1974 and comes from the Advanced Research Projects Agency Network (ARPANET) project, which created the first large, packet-switched network.
					
						</p>

						<p><idx>IP addresses</idx><idx>IPv4</idx> <idx>IPv6</idx>
						Most people are familiar with <term>IP addresses</term>, the unique number given to a host participating in an IP network. Currently there are two main versions of the IP protocol, <term>IPv4</term> and <term>IPv6</term>, and one of the major differences is in how man IP addresses are available. IPv4 supports 32 bit addresses and IPv6 supports 128 bit addresses. To give an idea of how big of a change that is, we have currently allocated all possible IPv4 addresses, but with IPv6 we could give an address to every grain of sand on the beaches of earth and still not run out.
					</p>

				<example>
					<p>IPv6 Security Implications</p>	

						<p><idx>network address translation</idx><idx>NAT</idx>
						From a security standpoint, the way addresses are used in IPv4 vs IPv6 has big consequences. Since there aren’t enough IPv4 addresses a typical internet user is assigned a local address that gets translated to an external IPv4 address when they route their packets through their router. This is referred to as 
						<term>Network Address Translation</term> (<term>NAT</term>) and is usually handled by an all-in-one device that also makes sure external entities cannot connect to the internal network.
					</p>


						<p>

						With IPv6 addresses each host on that same 
							<em>internal</em> network can be given an external IPv6 address. A 
							<em>basic</em> IPv6 router may simply pass the packets to the network without blocking connections to the internal network. If the machines are not hardened or a firewall is not put in place/enabled the machines could be subject to attack.
					
						</p>

						<p>
						As a computer security specialist it is important to test not only IPv4 connectivity, but also IPv6 to ensure that your network is configured appropriately.
					</p>
				</example>

					</subsection>
					<subsection xml:id="icmp">
						<title>ICMP</title>


						<p><idx>ICMP</idx><idx>internet control message protocol</idx> 

						<term>Internet Control Message Protocol</term> (<term>ICMP</term>) is largely used to send messages between systems when IP doesn’t work. For example, lets say we tried to connect to a host but our router doesn’t know how to get there. Our router can send us an ICMP 
							<em>Destination Unreachable</em> message to let us know that something is going wrong. Because ICMP messages work at the network layer, we will receive this message even if there is an issue with the internet layer.
					
						</p>
						<p><idx><c>ping</c></idx> 
						The most common use for ICMP is the 
							<term><c>ping</c></term> command. 
							<c>ping</c> sends an ICMP echo request to check to see if a host is up. By responding to the request with the data included in the request we can assume that the host is up and functioning.
					
						</p>

						<p><idx>TTL</idx><idx>time to live</idx><idx><c>traceroute</c></idx>

						ICMP is also used in the 
							<c>traceroute</c> command. 
							<c>traceroute</c> incrementally increase the <term>Time To Live</term> (<term>TTL</term>) field of ICMP packets and watches for 
							<em>TTL Exceeded</em> messages to determine what route packets are taking to get to a host. Example 
							<term><c>traceroute</c></term> output is shown below:
					
						</p>
						<pre>traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets
 1  ryan.njitdm.campus.njit.edu (172.24.80.1)  0.217 ms  0.200 ms  0.252 ms
 2  ROOter.lan (192.168.2.1)  5.790 ms  5.765 ms  6.275 ms
 3  * * *
 4  B4307.NWRKNJ-LCR-21.verizon-gni.net (130.81.27.166)  19.166 ms  19.144 ms  21.097 ms
 5  * * *
 6  0.ae1.GW7.EWR6.ALTER.NET (140.222.2.227)  12.376 ms  14.634 ms 0.ae2.GW7.EWR6.ALTER.NET (140.222.2.229)  9.805 ms
 7  209.85.149.208 (209.85.149.208)  9.782 ms  10.331 ms  9.192 ms
 8  * * *
 9  dns.google (8.8.8.8)  11.313 ms  9.761 ms  9.758 ms</pre>
 <note>
	<p>
		Notice these routers not responding to ICMP packets.
	</p>
 </note>

						<p>
						Despite the usefulness of ICMP, ICMP packets from external sources are often ignored. Network engineers use ICMP to troubleshoot their own networks, but it would be a security issue to allow outside parties to do the same. As such, do not expect all external hosts to respond to pings. They may still be up, but you’ll need to figure out 
							<url href="https://nmap.org/book/man-host-discovery.html">another way to detect them.</url>
						</p>

					</subsection>
					<subsection xml:id="nat">
						<title>NAT</title>


						<figure xml:id="fig-nat-router">
						<caption></caption>
						<image source="nat.svg">
							<shortdescription>A diagram illustrating how a NAT router enables multiple devices on a private network to share a single public IP address to access the internet.</shortdescription>
							<description>
								<p>This diagram shows a basic Network Address Translation (NAT) scenario. Three client devices with private IP addresses (192.168.1.50, 192.168.1.51, and 192.168.1.52) are on a local network. They connect to a NAT Router, which has a local interface IP (192.168.1.1) and a single public IP address (128.235.176.43). The NAT router translates the private IP addresses of the client devices to its own public IP address when they access the Internet, allowing multiple devices to share one public IP.</p>
							</description>
						</image>
					</figure>

						<p><idx>network address translation</idx><idx>NAT</idx>
						<term>Network address translation</term> (<term>NAT</term>) is primarily used to allow local IP address to share a public IPv4 address. Given the lack of IPv4 address space many devices have to share a single address. As mentioned when discussing IPv6, NAT routers often also include security features such as a stateful firewall as the complexity of the hardware required to perform NAT is equivalent to what would be needed for a firewall.

					</p>
					</subsection>
					<subsection xml:id="ipsec">
						<title>IPsec</title>

						<p><idx>IPsec</idx><idx>internet protocol security</idx> 

						<term>Internet Protocol Security</term> (<term>IPsec</term>) is used to set up a point-to-point encryption tunnel to secure data in transit across IP networks. IPsec is used primarily in dedicated VPN links and makes use of three main parts: SA, ESP, and AH:
					</p>

						<p>
							<ul>
								<li>

									<p><idx>SA</idx><idx>security association</idx> 
												<term>SA</term> stands for <term>security association</term> and is a channel used to set up encryption parameters and exchange keys. This happens via UDP on port 500.
											</p>
								</li>
								<li>
									<p><idx>ESP</idx><idx>encapsulating security protocol</idx> 
												<term>ESP</term> stands for <term>encapsulating security protocol</term> and is used to encrypt IP headers and payloads. It is sent using standard IP packets with the protocol field set to 50.
											</p>
								</li>
								<li>
									<p><idx>AH</idx><idx>authentication header</idx> 
												<term>AH</term> stands for <term>authentication header</term> and they can optionally be used in standard IP packets with the protocol field set to 51. AH simply ensures that a packet hasn’t been tampered with.

											</p>
								</li>
							</ul>
						</p>

					</subsection>
				</section>
				<section xml:id="transport-layer-protocols">
					<title>Transport Layer Protocols</title>


					<subsection xml:id="tcp">
						<title>TCP</title>

						<p><idx>TCP</idx><idx>transmission control protocol</idx>
						<term>Transmission Control Protocol</term> (<term>TCP</term>) is at the heart of most networks. It provides for reliable communication via a three way hand shake, breaks large data segments into packets, ensures data integrity, and provides flow control for those packets. This all comes at a cost of course, and this connection-oriented protocol typically has higher latency than its counterparts. Given the complex nature of TCP is has often been targeted for attacks. TCP stacks are constantly adapting and changing (within the parameters of the protocol) to avoid DoS and MitM attacks.
						</p>
							<note>
								<p>
								For an interesting example of how you can change but still follow a protocol, check out <url href="https://en.wikipedia.org/wiki/SYN_cookies">SYN cookies</url>.
								</p>
							</note>

					</subsection>
					<subsection xml:id="udp">
						<title>UDP</title>


						<p><idx>UDP</idx><idx>user datagram protocol</idx>

						<term>User Datagram Protocol</term> (<term>UDP</term>) is a connectionless protocol designed for instances where TCP may have too much latency. UDP achieves this performance boost by not having handshaking or flow control. The result is a speedy protocol that sometimes drops datagrams. UDP is often used as the basis for gaming or streaming protocols where the timing of the packets is more important that whether or not they all arrive. UDP does still employ checksums so you can be sure of the integrity of any UDP packets that you do receive.
					</p>

					</subsection>
					<subsection xml:id="common-ports-and-services">
						<title>Common Ports and Services</title>

	

						<p><idx>port numbers</idx>
						<term>Port numbers</term> are used in a transport layer connection to specify which service to connect to. This allows a single host to have multiple services running on it. Ports 0 to 1023 are 
							well-known ports and typically support a commonly used service. In most operating systems it takes administrative privileges to bind to a Well-known port and listen for connections. Registered ports range from 1024 to 49151 and do not require administrative privileges to run a service on. You may find many things listening on these ports as any user can have a service on them. Lastly ports 49152 to 65535 are used dynamically by applications as needed.
					
						</p>

						<p>
						It is important to know some commonly used ports as the services running on these ports may be subject to an attack. When scanning a machine, only necessary ports should be open.
					</p>

					<table>
						<title>Common Port Numbers and Their Usage</title>
						<tabular>
						
						<row>
							<cell><em>Port Number</em></cell>
							<cell><em>L4 Protocol</em></cell>
							<cell><em>Usage</em></cell>
						</row>
						<row>
							<cell>20</cell>
							<cell>TCP</cell>
							<cell>File Transfer Protocol (FTP) Data Transfer</cell>
						</row>
						<row>
							<cell>21</cell>
							<cell>TCP</cell>
							<cell>FTP Command Control</cell>
						</row>
						<row>
							<cell>22</cell>
							<cell>TCP</cell>
							<cell>Secure Shell (SSH)</cell>
						</row>
						<row>
							<cell>23</cell>
							<cell>TCP</cell>
							<cell>Telnet Remote Login Service</cell>
						</row>
						<row>
							<cell>25</cell>
							<cell>TCP</cell>
							<cell>Simple Mail Transfer Protocol (SMTP) E-Mail</cell>
						</row>
						<row>
							<cell>53</cell>
							<cell>TCP, UDP</cell>
							<cell>Domain Name System (DNS)</cell>
						</row>
						<row>
							<cell>67, 68</cell>
							<cell>UDP</cell>
							<cell>Dynamic Host Configuration Protocol (DHCP)</cell>
						</row>
					
						<row>
							<cell>69</cell>
							<cell>UDP</cell>
							<cell>Trivial File Transfer Protocol (TFTP)</cell>
						</row>
					
						<row>
							<cell>80</cell>
							<cell>TCP</cell>
							<cell>Hypertext Transfer Protocol (HTTP)</cell>
						</row>
					
						<row>
							<cell>110</cell>
							<cell>TCP</cell>
							<cell>Post Office Protocol (POP3) E-Mail</cell>
						</row>
					
						<row>
							<cell>119</cell>
							<cell>TCP, UDP</cell>
							<cell>Network News Transfer Protocol (NNTP)</cell>
						</row>
					
						<row>
							<cell>123</cell>
							<cell>UDP</cell>
							<cell>Network Time Protocol (NTP)</cell>
						</row>
					
						<row>
							<cell>137–139</cell>
							<cell>TCP, UDP</cell>
							<cell>NetBIOS</cell>
						</row>
						

						<row>
							<cell>143</cell>
							<cell>TCP</cell>
							<cell>Internet Message Access Protocol (IMAP) E-Mail</cell>
						</row>
					
						<row>
							<cell>161, 162</cell>
							<cell>TCP, UDP</cell>
							<cell>Simple Network Management Protocol (SNMP)</cell>
						</row>
					
						<row>
							<cell>194</cell>
							<cell>TCP, UDP</cell>
							<cell>Internet Relay Chat (IRC)</cell>
						</row>
					
						<row>
							<cell>389</cell>
							<cell>TCP, UDP</cell>
							<cell>Lightweight Directory Access Protocol (LDAP)</cell>
						</row>
					
						<row>
							<cell>443</cell>
							<cell>TCP</cell>
							<cell>HTTP Secure (HTTPS) — HTTP over TLS/SSL</cell>
						</row>
					
						<row>
							<cell>3389</cell>
							<cell>TCP, UDP</cell>
							<cell>Microsoft Terminal Server (RDP)</cell>
						</row>
						</tabular>
					</table>

					<p>

					</p>

					</subsection>
				</section>
				<section xml:id="application-layer-protocols">
					<title>Application Layer Protocols</title>


					<subsection xml:id="dhcp">
						<title>DHCP</title>

						<p><idx>DHCP</idx><idx>dynamic host configuration protocol</idx> 
							<idx>DNS</idx><idx>domain name servers</idx> 

						<term>Dynamic Host Configuration Protocol</term> (<term>DHCP</term>) is used to allow new clients on a network to obtain an IP address and information about services provided. IPv4 addresses can be thought of as being in two groups: static addresses and dynamic addresses. Dynamic addresses are distributed by a DHCP server for a particular lease time. When the time is up, the DHCP server may distribute the address to another client. DHCP servers can also give information about proxies, 
						<term>Domain Name Servers</term> (<term>DNS</term>), gateways and even where to get a 
							<url href="https://en.wikipedia.org/wiki/Preboot_Execution_Environment">where to get a kernel to boot an OS over the network!</url>
						</p>


						<p><idx>ARP</idx><idx>address resolution protocol</idx>

						Given the dynamic nature of modern networks, with clients coming and going, DHCP is the standard. From a security standpoint someone impersonating a DHCP server can wreak havoc on a network. These rogue DHCP servers can cause traffic to be redirected to initiate MitM attacks or cause DoS attacks. DHCP relies on broadcast 
						<term>Address Resolution Protocol</term> (<term>ARP</term>) messages and does not make use of authentication, meaning that once an attacker is on the same Ethernet segment as the victim machines all bets are off.
					</p>

					</subsection>
					<subsection xml:id="http">
						<title>HTTP</title>


						<p><idx>request</idx>
							<idx>response</idx>
							<idx>path</idx>
							<idx>HTTP</idx><idx>hypertext transfer protocol</idx>

						<term>Hypertext Transfer Protocol</term> (<term>HTTP</term>) is a text based protocol that governs how web traffic moves. It is built on the concept of a 
							<em>request</em> and a 
							<em>response</em>. A typical request has an 
							<em>method</em> and a 
							<em>path</em>, such as 
							<c>GET /index.html</c> which would retrieve the landing page of a website. Responses have a code, message, and optionally data. Some standard responses are shown below:
					
						</p>

						<table>
							<title></title>
							<col width="50%" />
							<col width="50%" />
							<tabular>
								<row header="yes">
									<cell halign="left">Code</cell>
									<cell halign="left">Message</cell>
								</row>
								<row class="odd">
									<cell halign="left">200</cell>
									<cell halign="left">OK</cell>
								</row>
								<row class="even">
									<cell halign="left">202</cell>
									<cell halign="left">Accepted</cell>
								</row>
								<row class="odd">
									<cell halign="left">400</cell>
									<cell halign="left">Bad Request</cell>
								</row>
								<row class="even">
									<cell halign="left">401</cell>
									<cell halign="left">Unauthorized</cell>
								</row>
								<row class="odd">
									<cell halign="left">403</cell>
									<cell halign="left">Forbidden</cell>
								</row>
								<row class="even">
									<cell halign="left">404</cell>
									<cell halign="left">Not Found</cell>
								</row>
								<row class="odd">
									<cell halign="left">500</cell>
									<cell halign="left">Internal Server Error</cell>
								</row>
								<row class="even">
									<cell halign="left">502</cell>
									<cell halign="left">Bad Gateway</cell>
								</row>
								<row class="odd">
									<cell halign="left">503</cell>
									<cell halign="left">Service Unavailable</cell>
								</row>
							</tabular>
						</table>

            
						<p><idx>headers</idx>
						Both requests and responses can take advantage of 
							<term>headers</term>, arbitrary lines of text following the initial request or response. Since headers were designed to be open-ended, many new headers have been added over time. A modern web request/response usually has far more information in the headers than just the basics defined in HTTP 1.1. Unencrypted HTTP traffic is sent over port 80 and is vulnerable to attack as all information is sent in cleartext.
					
						</p>

					</subsection>
					<subsection xml:id="ssltls">
						<title>SSL/TLS</title>


						<figure xml:id="fig-tls-handshake">
						<caption></caption>
						<image source="tls.svg">
							<shortdescription>A sequence diagram illustrating the key steps in a simplified TLS handshake between a client and a server.</shortdescription>
							<description>
								<p>This diagram shows a simplified sequence of messages exchanged between a client and a server during a Transport Layer Security (TLS) handshake. The process begins with TCP's three-way handshake (SYN from client to server, SYN ACK from server to client, and ACK from client to server). Immediately following the TCP ACK, the client initiates the TLS handshake by sending a "ClientHello" message. The server responds with "ServerHello," its digital "Certificate," and a "ServerHelloDone" message. The client then processes this information and sends a "ClientKeyExchange" message (containing the premaster secret), a "ClientCipherSpec" message to activate the newly negotiated cryptographic parameters, and a "Finished" message (an encrypted hash of the handshake so far). The server, in turn, sends its "ChangeCipherSpec" message and its own "Finished" message. Upon successful exchange and verification of these messages, the secure TLS channel is established.</p>
							</description>
						</image>
					</figure>

						<p><idx>SSL</idx><idx>secure sockets layer</idx>
							<idx>TLS</idx><idx>transport layer security</idx> 

						<term>Secure Sockets Layer</term> (<term>SSL</term>) or the more modern nomenclature 
						<term>Transport Layer Security</term> (<term>TLS</term>) is a protocol that allows cleartext protocols used on the web to be encrypted. It is a general purpose protocol, designed as a layer through which other protocols communicate. Some protocols typically wrapped in TLS include HTTP, SMTP, IMAP, VoIP, and many VPN protocols. TLS uses a handshake to exchange certificate information as shown in the diagram. It should be noted that at the time of writing TLS 1.3 is the most current version, but only half of websites support it. TLS 1.2, the most common version, is still considered safe if best practices are followed and TLS 1.1 or lower is considered depreciated.
					</p>

					</subsection>
					<subsection xml:id="https">
						<title>HTTPS</title>


						<figure xml:id="fig-https-indicator">
						<caption></caption>
						<image source="https.png">
							<shortdescription>An icon depicting a green padlock next to "https://" text, symbolizing a secure HTTPS web connection.</shortdescription>
							<description>
								<p>This image shows a common visual indicator of a secure HTTPS connection, often seen in web browser address bars. It features a green padlock icon immediately to the left of the text "https://". The padlock signifies that the communication with the website is encrypted using TLS/SSL, ensuring data privacy and integrity. This assures the user that their connection to the site is secure.</p>
							</description>
						</image>
					</figure>


						<p>
							<url href="https://flic.kr/p/qi1eYu">HTTPS 
								<q>icon</q>
							</url> by 
							<url href="https://www.flickr.com/photos/smemon/">Sean MacEntee</url> used under 
							<url href="https://creativecommons.org/licenses/by/2.0/deed.en">CC-BY 2.0</url>.
					
						</p>


						<p><idx>HTTPS</idx><idx>hypertext transfer protocol secure</idx> 

						<term>Hypertext Transfer Protocol Secure</term> (<term>HTTPS</term>) solves the problem of unencrypted traffic by wrapping HTTP requests in TLS. HTTPS traffic uses port 443 and is typically signified in a browser with a lock icon in the upper left-hand corner. By clicking on the icon users can learn more about the certificates being used for communication. Utilizing a robust PKI HTTPS allows for safe HTTP communication between client and server.
					</p>

					</subsection>
					<subsection xml:id="rdp">
						<title>RDP</title>

						<p><idx>RDP</idx><idx>remote desktop protocol</idx>

						<term>Remote Desktop Protocol</term> (<term>RDP</term>) is build into Windows and is typically used to control a machine remotely. It works over port 3389 via TCP or UDP. While RDP can be quite useful for performing remote administration on a remote machine, it can also be a large security hole if a bad actor gains access. RDP use in ransomware attacks is on the rise as ransomware programs may use RDP to find other machines to attack.
					</p>

					</subsection>
					<subsection xml:id="telnet">
						<title>Telnet</title>

						<p><idx>telnet</idx>

						<term>Telnet</term> is an antiquated remote administration tool that gives access to a shell via a cleartext channel. Telnet runs on port 23 and while still occasionally in use it should largely be phased out. You will still find telnet in embedded applications and legacy systems. You may also see the client being used to inspect other types of traffic. For example, you can use a telnet client to submit HTTP requests or send email via SMTP.
					</p>
					</subsection>
					<subsection xml:id="ssh">
						<title>SSH</title>


						<p><idx>SSH</idx><idx>secure shell</idx> 

						<term>Secure Shell</term> (<term>SSH</term>) is the most widely deployed remote administration tool. SSH provides access to a shell via an encrypted connection. SSH supports many options including SOCKS5 proxies, port forwarding, and the usage of multiple authentication schemes: password, key, hardware device, etc. SSH uses TCP on port 22.
					</p>

					</subsection>
					<subsection xml:id="ldap">
						<title>LDAP</title>

						<figure xml:id="fig-ldap">
						<caption></caption>
						<image source="ldap.svg">
							<shortdescription>Diagram illustrating an example LDAP directory tree structure.</shortdescription>
							<description>
							<p>The diagram displays a hierarchical tree structure representing an LDAP (Lightweight Directory Access Protocol) directory. At the top is the "Root" node. Below the root are top-level domain components: "dc=net", "dc=com", and "dc=org". The "dc=com" branch further expands to an "Organization" labeled "dc=example". Under "dc=example", there are two "Organization Unit" branches: "ou=People" and "ou=Servers". Finally, under "ou=People", there is a "Person" entry labeled "udid=jsmith". Lines connect the nodes, showing their hierarchical relationships. Arrows point from labels "Organization", "Organization Unit", and "Person" to their respective example nodes in the tree.</p>
							</description>
						</image>
						</figure>

						<p>

							<idx>LDAP</idx><idx>lightweight directory access protocol</idx> 
							<idx>AD</idx><idx>active directory</idx>

							<idx>LDAPS</idx>
						<term>Lightweight directory access protocol</term> (<term>LDAP</term>) is used for accessing and maintaining directory information services. It’s primary use is with Windows 
						<term>Active Directory</term> (<term>AD</term>) where it can be used to obtain information regarding users and resources from an AD server. Clients can authenticate through the server and obtain privileges to read or read/write certain entries. LDAP did not originally support encryption, so LDAP over SSL 
						(<term>LDAPS</term>) was developed. LDAP uses TCP and UPD over port 389 and LDAPS uses TCP over port 636.
					</p>

					</subsection>
					<subsection xml:id="dns">
						<title>DNS</title>


						<p><idx>DNS</idx><idx>domain name system</idx> 
						<idx>TLD</idx><idx>top level domain</idx>

						<term>Domain Name System</term> (<term>DNS</term>) is used to resolve domain names to IP addresses. Domain names are the simple names people are accustomed to for websites, such as 
							<c>njit.edu</c> as opposed to 
							<c>54.83.189.142</c>. Names are significantly easier for people to remember than IP addresses. In order for a computer to resolve a name, it first queries a local cache, then its primary DNS server. Assuming the DNS server cannot find the name it will query a Root server for a 
							<term>Top Level Domain</term> (<term>TLD</term>) server, which maintains a listing of Authoritative Nameservers for that particular domain (edu, com, net, org, gov, etc.). Finally once an authoritative nameserver is found it will respond with the IP address for that particular hostname which will be cached and sent back through the user’s primary DNS server to the user.
					
						</p>
						<p>
						DNS is designed to be resilient and decentralized but unfortunately the traffic is not authenticated or encrypted. This has made it a target for MitM attacks. Likewise cache hits and misses 
							<url href="https://kb.isc.org/docs/aa-00509">can yield information as to what names have been recently resolved</url> (as was the case in discovering the extent of the Sony Rootkit). The recursive nature has of DNS has also allowed for DoS attacks in the past, but much of that has been solved by limiting recursive queries to the user-facing DNS servers (ie. the one given to you by your DHCP request). DNS operates via UDP (and occasionally TCP) on port 53.
					
						</p>

					</subsection>
					<subsection xml:id="dnssec">
						<title>DNSSEC</title>


						<p><idx>DNSSEC</idx><idx>domain name system security Extensions</idx> 

						<term>Domain Name System Security Extensions</term> (<term>DNSSEC</term>) is a suite of extension specifications designed to authenticate responses to domain name lookups. This can help prevent MitM attacks by checking the digital signature of the responding server. While this is certainly helpful, it is important to note that DNSSEC does not provide confidentiality. DNS resolutions can still be monitored by anyone who has access to the traffic.
					</p>

					</subsection>
					<subsection xml:id="imappop3">
						<title>IMAP/POP3</title>


						<p>
							<idx>IMAP</idx><idx>internet message access protocol</idx> 
							<idx>POP3</idx><idx>post office protocol 3</idx>

						<term>Internet Message Access Protocol</term> (<term>IMAP</term>) and <term>Post Office Protocol 3</term> (<term>POP3</term>) are two protocols used to retrieve email from a server. IMAP is the more recent protocol which supports saving mail on the sever and folders. POP3 is more primitive, supporting only the retrieval (and subsequent deletion from the server) of emails. Both protocols use cleartext and are now commonly run over TLS. POP3 defaults to TCP port 110 or 995 if using TLS. IMAP defaults to TCP port 143 or 993 if using TLS. In the age of webmail it is easy to forget about these protocols, but a security specialist must keep them in mind as they may still be used in support of corporate devices.
					</p>

					</subsection>
					<subsection xml:id="smtp">
						<title>SMTP</title>


						<p>
							<idx>SMTP</idx><idx>simple mail transfer protocol</idx>
							<idx>MX</idx><idx>mail exchange</idx>

						<term>Simple Mail Transfer Protocol</term> (<term>SMTP</term>) is used for sending/forwarding email. As it states, it is a simple protocol consisting of lines of text. Basic SMTP used TCP on port 25. SMTP was later expanded to support authentication and finally wrapped in TLS still using TCP on port 587. SMTP servers accept outgoing mail from (hopefully) authenticated clients, route mail to other SMTP servers based on the 
						<term>Mail Exchange</term> (<term>MX</term>) information in DNS records, and accept mail for their domain from other SMTP servers. Various checks have been implemented in SMTP servers to ensure that messages from domains 
							<em>actually</em> come from those domains. This is largely used to combat spam, which continues to be a problem.
					
						</p>
					</subsection>
					<subsection xml:id="ntp">
						<title>NTP</title>


						<p>
							<idx>NTP</idx><idx>network time protocol</idx>

						<term>Network Time Protocol</term> (<term>NTP</term>)  uses UDP over port 123 to sync the system time with a time server. NTP servers are layered in stratums, with the lowest stratums being closest to the most accurate sources of time, atomic clocks, GPS, etc. NTP is important as many protocols, including several key exchanges, require system clocks to be in sync. System clocks are also used to check when certificates expire and used in logs to indicate when something happened. Without an accurate, synchronized system clock many things will fail in surprising ways.
					</p>

					</subsection>
					<subsection xml:id="ftp">
						<title>FTP</title>


						<p>
							<idx>FTP</idx><idx>file transfer protocol</idx>

						<term>File Transfer Protocol</term> (<term>FTP</term>) is a relatively simple, text-based protocol for sending files between machines. FTP uses TCP on port 21 and traditionally establishes two channels: one for protocol messages, and one binary channel for data. The interesting thing about this setup is that the FTP server would initiate the connection of the data channel from server to client, meaning that in many NAT situations where the client couldn’t be easily reached behind a firewall it would fail. The solution to this problem was passive FTP which uses one channel established by the client.
					</p>
						<p>
						Despite this initial shortcoming, FTP has proven to be incredibly popular and is still used in many corporate environments. You may see FTP being used to transmit bulk data for import to systems or used to update firmware in embedded systems. You can use FTP with a commandline client, 
							<c>ftp</c>, a graphical client such as Filezilla or SecureFX, or even in most web browsers with the 
							<c>ftp://</c> URL scheme.
					
						</p>
						<p>

							<idx>SFTP</idx><idx>secure FTP</idx>

						Unfortunately FTP does not support authentication systems other than passwords and the passwords are sent in plaintext. As such 
						<term>Secure FTP</term> (<term>SFTP</term>) is recommended. SFTP uses an SSH connection to send and receive files over an encrypted channel. SFTP also supports all SSH authentication methods.
					</p>

					</subsection>
					<subsection xml:id="snmp">
						<title>SNMP</title>

						<figure xml:id="fig-snmp">
						<caption></caption>
						<image source="snmp.png">
							<shortdescription>Diagram illustrating the typical SNMP message exchange mechanism between an NMS Management Station and an SNMP Agent.</shortdescription>
							<description>
							<p>The diagram shows the interaction between a Network Management Station (NMS) and an SNMP Agent. The NMS Management Station, on the left, is depicted as listening for Traps and Informs on UDP port 162. The SNMP Agent, on the right, listens for requests on UDP port 161 and has access to a Management Information Base (MIB). The typical message exchange includes the NMS sending GetRequest and GetNextRequest messages to the Agent. The Agent responds to these with GetResponse messages. Additionally, the Agent can proactively send Trap or Inform messages to the NMS to notify it of significant events. The entire process is labeled as a "Typical SNMP Message Exchange Mechanism."</p>
							</description>
						</image>
						</figure>

						<p>
							<url href="https://commons.wikimedia.org/wiki/File:SNMP_TRAFFIC1.png">SNMP by Deegii121314</url> used under 
							<url href="https://commons.wikimedia.org/wiki/File:SNMP_TRAFFIC1.png">CC-BY-SA 4.0</url>
						</p>

						<p><idx>simple network management protocol</idx><idx>SNMP</idx> 
						<term>Simple Network Management Protocol</term> (<term>SNMP</term>) is used for gathering information about the workings of a network. It is broken into two groups: clients using UDP port 161 (TLS 10161) and a manager using UDP port 162 (TLS 10162). The manager collects messages from the clients regarding the operations of the network and uses this information to take actions as necessary. SNMP can be used to pass information about the temperature of a machine, how many connections it currently has, the channel capacity currently being utilized, etc. SNMP is currently up to version 3 which is encrypted and requires authentication. This is particularly important because SNMP is a very powerful protocol which exchanges information that could potentially be very valuable to an attacker. Access to SNMP should be limited and its usage on a network should be monitored.
					</p>


					</subsection>
				</section>
				<section xml:id="lab-scanning-with-nmap">
					<title>Lab: Scanning with nmap</title>

					<introduction>
					<p>
					For this lab, we need to use Docker, so you can again choose a Github Codespace or a local Docker installation. 
					</p>			
				</introduction>
				<subsection xml:id="nmap-codespace">
					<title>Using nmap in a Github Codespace</title>
					<p>
						Go <url href="https://github.com/pearcej/security-nmap">github.com/pearcej/security-nmap</url>. Then:
							<ol>
								<li>
									<p>
										Fork this codespace into your own Github repository.
									</p>
								</li>
								<li>
									<p>
										Navigate to your repository on GitHub.
									</p>
								</li>
								<li>
									<p>
										Click the green Code button and select Codespaces.
									</p>
								</li>
								<li>
									<p>
										Click "Create codespace on main".
									</p>
								</li>
								<li>
									<p>
										Wait for the codespace to be created.
									</p>
								</li>
							</ol>
						Next, follow the directions in <xref ref="lab-instructions-for-nmap" /> but be sure to either stop or delete this codespace when you are done by clicking the "Stop" button or the "Delete" button in the Codespaces tab of your repository.
					</p>
					
				</subsection>
				<subsection xml:id="nmap-local">
					<title>Using nmap in a local Docker installation</title>
					<p>
					Start by downloading and extracting the files required. Download 
						<url href="https://github.com/rxt1077/it230/raw/main/labs/nmap.zip">nmap.zip</url> and extract it to a directory you can access from the shell. 
					</p>
					</subsection>
					<subsection xml:id="lab-instructions-for-nmap">
						<title>Lab Instructions for nmap</title>
					<p>
						
						Open a shell in that directory (it should have a 
						<c>docker-compose.yml</c> in it and a 
						<c>victim</c> and 
						<c>scanner</c> directory). Since we will be simulating multiple machines in this lab, we will make use of Docker Compose which was already installed with Docker. Docker Compose reads a 
						<c>docker-compose.yml</c> file which should already be in your 
						<c>nmap</c> directory. Run 
						<c>docker-compose up --build --detach</c> to build and run the images in the background:
					</p>

					<pre>PS C:\Users\rxt1077\temp\nmap&gt; docker-compose up --build --detach
Building victim
[+] Building 2.9s (15/15) FINISHED
 =&gt; [internal] load build definition from Dockerfile                                                                                                   0.1s
 =&gt; =&gt; transferring dockerfile: 518B                                                                                                                   0.0s
 =&gt; [internal] load .dockerignore                                                                                                                      0.1s
 =&gt; =&gt; transferring context: 2B                                                                                                                        0.0s
 =&gt; [internal] load metadata for docker.io/library/debian:latest                                                                                       0.0s
 =&gt; [ 1/10] FROM docker.io/library/debian                                                                                                              0.0s
 =&gt; [internal] load build context                                                                                                                      0.0s
 =&gt; =&gt; transferring context: 640B                                                                                                                      0.0s
 =&gt; CACHED [ 2/10] RUN apt-get -y update                                                                                                               0.0s
 =&gt; CACHED [ 3/10] RUN apt-get -y install proftpd-basic                                                                                                0.0s
 =&gt; CACHED [ 4/10] RUN sed -i "1s/.*/root:$6$.DEC7ti\/4959zEK9$H7BPwBTz6tISYG8oZuhXLS5L3ZPYwdzzQNQTg8m4Ql3ebX9U\/afVhi4OSpK3mNTSpT8DefJ2USdWuT5DHOkRY  0.0s
 =&gt; [ 5/10] RUN sed -i "/^root/d" /etc/ftpusers                                                                                                        0.4s
 =&gt; [ 6/10] COPY bad.conf /etc/proftpd/conf.d/                                                                                                         0.0s
 =&gt; [ 7/10] RUN chsh -s /bin/bash ftp                                                                                                                  0.6s
 =&gt; [ 8/10] RUN mkdir -p /home/ftp/incoming                                                                                                            0.5s
 =&gt; [ 9/10] RUN cp /etc/shadow /home/ftp/incoming/shadow.backup                                                                                        0.6s
 =&gt; [10/10] RUN chown -R ftp.users /home/ftp                                                                                                           0.5s
 =&gt; exporting to image                                                                                                                                 0.2s
 =&gt; =&gt; exporting layers                                                                                                                                0.2s
 =&gt; =&gt; writing image sha256:dc9af53b250b4f7fcfbe5a6668a540bd02ebef0353c5927ed4591a512363e831                                                           0.0s
 =&gt; =&gt; naming to docker.io/library/nmap_victim                                                                                                         0.0s

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
Building scanner
[+] Building 0.1s (7/7) FINISHED
 =&gt; [internal] load build definition from Dockerfile                                                                                                   0.0s
 =&gt; =&gt; transferring dockerfile: 111B                                                                                                                   0.0s
 =&gt; [internal] load .dockerignore                                                                                                                      0.0s
 =&gt; =&gt; transferring context: 2B                                                                                                                        0.0s
 =&gt; [internal] load metadata for docker.io/library/debian:latest                                                                                       0.0s
 =&gt; [1/3] FROM docker.io/library/debian                                                                                                                0.0s
 =&gt; CACHED [2/3] RUN apt-get -y update                                                                                                                 0.0s
 =&gt; CACHED [3/3] RUN apt-get -y install nmap ftp john                                                                                                  0.0s
 =&gt; exporting to image                                                                                                                                 0.0s
 =&gt; =&gt; exporting layers                                                                                                                                0.0s
 =&gt; =&gt; writing image sha256:14ba503b7925089023184d783c53c22c4167fdf2338df0e85143daedf8b458ac                                                           0.0s
 =&gt; =&gt; naming to docker.io/library/nmap_scanner                                                                                                        0.0s

Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them
Starting nmap_scanner_1  ... done
Recreating nmap_victim_1 ... done</pre>

					<p>
					Now we actually have two containers running, one named 
						<c>victim</c> which is our target machine and another named 
						<c>scanner</c> which we will use to learn about nmap. Lets start a BASH shell on 
						<c>scanner</c> and work from there:
				
					</p>

					<pre>PS C:\Users\rxt1077\temp\nmap&gt; docker-compose run scanner bash
Creating nmap_scanner_run ... done
root@7b6d733cc03a:/</pre>

	<note>
		<p>
			Notice the prompt change. We are now 
									<em>inside</em> the 
									<c>scanner</c> container running BASH.
		</p>
	</note>



					<p>
					Lets use the Linux 
						<c>ip addr</c> command to see what our IP address on this network is:
				
					</p>

					<pre>root@7b6d733cc03a:/# ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
165: eth0@if166: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.20.0.2/16 brd 172.20.255.255 scope global eth0
       valid_lft forever preferred_lft forever</pre>

					<p>
					We care about the 
						<c>eth0</c> device, so as you can see on my machine the address is 
						<c>172.20.0.2</c>. We will use nmap’s ping scan to search for any device within the last 8 bits of our IP address (
						<c>/24</c>). You may notice that we are actually on a 
						<c>/16</c> subnet, but by limiting ourselves to 
						<c>/24</c> the scan will go 
						<em>much</em> faster.
				
					</p>

					<pre>root@7b6d733cc03a:/# nmap -sP 172.20.0.0/24
Starting Nmap 7.70 ( https://nmap.org ) at 2021-09-22 20:25 UTC
Nmap scan report for 172.20.0.1
Host is up (0.000076s latency).
MAC Address: 02:42:A6:CA:0D:77 (Unknown)
Nmap scan report for nmap_victim_1.nmap_default (172.20.0.3)
Host is up (0.000070s latency).
MAC Address: 02:42:AC:14:00:03 (Unknown)
Nmap scan report for 7b6d733cc03a (172.20.0.2)
Host is up.
Nmap done: 256 IP addresses (3 hosts up) scanned in 5.78 seconds</pre>

					<p>
					In this instance we found three other machines on the network. One of which is conveniently named victim.
				</p>


					<question>
						<p>
							Read the <url href="https://nmap.org/book/man-host-discovery.html">nmap documentation for host discovery</url>. 
						
							What other types of scans could you use if a host does not respond to an ICMP ping packet?
						</p>
					</question>

					<p>
					Now lets do a full scan on on the victim machine. Docker Compose does a nice job of resolving DNS requests for sensible names in the 
						<c>docker-compose.yml</c> file so we can refer to the host we want to scan as 
						<c>victim</c>.
				
					</p>

					<pre>root@7b6d733cc03a:/# nmap victim
Starting Nmap 7.70 ( https://nmap.org ) at 2021-09-22 20:37 UTC
Nmap scan report for victim (172.20.0.3)
Host is up (0.000018s latency).
rDNS record for 172.20.0.3: nmap_victim_1.nmap_default
Not shown: 999 closed ports
PORT   STATE SERVICE
21/tcp open  ftp
MAC Address: 02:42:AC:14:00:03 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 1.84 seconds</pre>

					<p>
					By default, nmap uses a 
						<url href="https://www.techtarget.com/searchnetworking/definition/SYN-scanning">SYN</url> scan against well known ports. This type of scan is harder to detect (as it does not fully open a connection) and can be run quickly.
				
					</p>


					<question>
						<p>
							What ports are open on the victim machine? Why is this particular protocol insecure?
						</p>
					</question>

					<p>
					nmap is capable of much more than just simple port scanning. nmap includes version detection and OS fingerprinting (among other things). To get a much better picture of what exactly 
						<c>victim</c> is running, you can use the 
						<c>-A</c> option:
				
					</p>

					<pre>root@7b6d733cc03a:/# nmap -A victim
Starting Nmap 7.70 ( https://nmap.org ) at 2021-09-22 20:44 UTC
Nmap scan report for victim (172.20.0.3)
Host is up (0.000096s latency).
rDNS record for 172.20.0.3: nmap_victim_1.nmap_default
Not shown: 999 closed ports
PORT   STATE SERVICE VERSION
21/tcp open  ftp     ProFTPD
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
|_drwxr-xr-x   1 ftp      users        4096 Sep 22 20:11 incoming
MAC Address: 02:42:AC:14:00:03 (Unknown)
No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=7.70%E=4%D=9/22%OT=21%CT=1%CU=44136%PV=Y%DS=1%DC=D%G=Y%M=0242AC%T
OS:M=614B95AE%P=x86_64-pc-linux-gnu)SEQ(SP=103%GCD=1%ISR=109%TI=Z%CI=Z%TS=A
OS:)OPS(O1=M5B4ST11NW7%O2=M5B4ST11NW7%O3=M5B4NNT11NW7%O4=M5B4ST11NW7%O5=M5B
OS:4ST11NW7%O6=M5B4ST11)WIN(W1=FE88%W2=FE88%W3=FE88%W4=FE88%W5=FE88%W6=FE88
OS:)ECN(R=Y%DF=Y%T=40%W=FAF0%O=M5B4NNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+
OS:%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)
OS:T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A
OS:=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%D
OS:F=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=4
OS:0%CD=S)

Network Distance: 1 hop

TRACEROUTE
HOP RTT     ADDRESS
1   0.10 ms nmap_victim_1.nmap_default (172.20.0.3)

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 28.39 seconds</pre>


					<question>
						<p>
							What additional information did you learn from the -A option? How do you think this could be exploited?
						</p>
					</question>


					<p>
					Now, using the 
						<c>scanner</c> container you are currently on see what you can find out about 
						<c>victim</c>. 
						<url href="https://linux.die.net/man/1/ftp">This man page may be of some help.</url>
					</p>


					<question>
						<p>
							BONUS: Remembering what you learned in the <em>Hash it Out</em> lab, what is the root password on the victim machine?
						</p>
					</question>

					<question>
						<p>
							BONUS: How can you test to see if you got it right? What does this say about how ProFTP is configured on <em>victim</em>?
						</p>
					</question>

					<p>
					When you are all done poking around, you can exit the shell and run 
						<c>docker-compose down</c> to stop 
						<c>victim</c> from running in the background.					</p>
						<note>
							

										<p>
							If you chose to use a Github codespace, don't forget to stop or delete the codespace by clicking the "Stop" button or the "Delete" button in the Codespaces tab of your repository.
						</p>
						</note>
					</subsection>
				</section>
				<section xml:id="protocols-review">
					<title>Review Questions</title>

					<p>
						<ol>
							<li>
								<p>
									<em>Compare and contrast SSH and Telnet. If you had to make a recommendation for which one to use, what would you choose and why?</em>
								</p>
							</li>
							<li>
								<p>
									<em>What are some security concerns associated with ARP? What steps can be taken to mitigate them?</em>
								</p>
							</li>
							<li>
								<p>
									<em>Describe three protocols used to send or receive email.</em>
								</p>
							</li>
						</ol>
					</p>

				</section>

</chapter>